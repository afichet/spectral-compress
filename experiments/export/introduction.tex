\section{Introduction}

In this supplemental, we benchmark our compression technique with different parameters using two spectral image databases. Our compression pipeline uses spectral EXR files as the input and outputs a collection of JPEG-XL files.

We also provide showcase how a simple compression scheme would compare. This scheme saves each band independently using the JPEG-XL compression without further processing.


\subsection{Spectral OpenEXR Conversion}

We use spectral OpenEXR files as input of our compression pipeline to have a consistent pipeline across the two databases. All images are first converted from their respective format to spectral OpenEXR prior to the compression.

For the CAVE database we get a set of grayscale PNGs 16~bits unsigned integers for each spectral band. To keep the full possible range of 16~bits unsigned integers values, we use a 32~bits float frame buffer per band in our spectral EXR conversion. We use the program \verb?cave-exr? from with the script \verb?experiment/cave_to_exr.py? to execute this conversion.

For the Bonn database, the native format is in \verb?.npz? Numpy format. We export the diffuse and specular maps in spectral EXR using a 32~bits float frame buffer per band. We use the script \verb?experiment/bonn_to_exr.py? to execute this conversion.

All OpenEXR files use ZIP compression. We also remove the ``\verb?R?'', ``\verb?G?'', ``\verb?B?'' layers to better compare the lossless compressed OpenEXR file with our proposed lossy compression scheme.


\subsection{Compression Parameters}

In this document we mainly compare the following parameters:

\begin{description}
    \item[Frame distance] It is a compression parameter of JPEG-XL. When set to 0, we use the JPEG-XL lossless compression mode. This parameter can be set from 0 to 15, with a higher number decreasing image quality in favor of file size. We use two frame distance parameters. One for the zeroth moment (DC) component and a second one for the first moment (AC) component. In this supplemental, we showcase two scenarios,
    \begin{itemize}
        \item DC with frame distance 0 (lossless) and first AC component with frame distance 1 (lossy).
        \item DC with frame distance 0.1 (lossy) and first AC component starting with frame distance 1 (lossy).
    \end{itemize}
    \item[Compression curve] We can generate a compression curve at runtime. The method for generating this curve is detailed in the article. When the compression curve is set to flat, all AC components use the same frame distance parameter. Otherwise, the frame distance is increased according to the error. In this supplemental, we showcase two scenarios,
    \begin{itemize}
        \item Flat curve: all AC components use the same frame distance parameter.
        \item Dynamic curve: the curve is computed at runtime with the frame distance starting from the parameter set for the first AC component.
    \end{itemize}
    \item[Chroma subsampling] We allow the subsampling of AC components while keeping the DC component at full resolution. Since most of the chroma information is held by AC components, we name this ``chroma subsampling''. In this supplemental, we showcase two scenarios,
        \begin{itemize}
            \item No chroma subsampling (1:1), the DC component and all AC components are kept at full resolution.
            \item Chroma subsampling (1:2), the DC component is kept at full resolution while AC components are stored at half of their native resolution.
        \end{itemize}
\end{description}

For each runs, the JPEG-XL effort parameter is set at 7, the default parameter of libjxl.

\subsection{Metrics}

\paragraph{Error}
We compare the accuracy of the reconstructed spectral image after our compression with RMSE per pixel and display a heatmap of the resulting values using the following formula:

\begin{align}
    \mathrm{RMSE}(x, y) = \sqrt{\frac{\sum_{\lambda = 0}^{N_\mathrm{bands} - 1} \left(I_\mathrm{ref}(x, y, \lambda) - I_\mathrm{cmp}(x, y, \lambda) \right)^2}{N_\mathrm{bands}}}
\end{align}

with:

\begin{tabularx}{\linewidth}{lX}
    $(x, y)$ & the pixel location on the heatmap, \\
    $I_\mathrm{ref}$ & the OpenEXR image used as the input of our pipeline, \\
    $I_\mathrm{cmd}$ & the OpenEXR image obtained after decompressing the image compressed with our pipeline. \\
\end{tabularx}\\

Then, we provide the RMSE over the whole image in the plots:

\begin{align}
    \mathrm{RMSE} =
        \sqrt{
            \frac{
                    \sum_{x = 0}^{\mathrm{width} - 1} \sum_{y = 0}^{\mathrm{height} - 1} \sum_{\lambda = 0}^{N_\mathrm{bands} - 1}
                        \left(
                            I_\mathrm{ref}(x, y, \lambda) - I_\mathrm{cmp}(x, y, \lambda)
                        \right)^2
                }
                {\mathrm{width} \cdot \mathrm{height} \cdot N_\mathrm{bands}}
        }
\end{align}


\paragraph{Compression Ratio}

We compute the compression ratios as the division of the original spectral OpenEXR image without the ``\verb?R?'', ``\verb?G?'', ``\verb?B?'' layers with ZIP compression by the sum of the JPEG-XL files necessary to reconstruct a spectral OpenEXR image.


\paragraph{Timings}

All the computations were done on an Intel Core i9-10980XE CPU with 128~Gb of RAM (Dell Precision 5820 Tower X-Series). On each image, we provide the timings for the execution of the whole compression pipeline. For the summary section, we provide  instead the average timing per pixel since all images do not share the same resolution.


\paragraph{Previews}

We provide an sRGB version of the spectral OpenEXR images as preview. The exposure is set to 0 for the Bonn databse and set to -6.5 for the CAVE database.

We also show an inset of the RGB versions and the diffs images of the 50x50~pixels center of the images to better compare the potential visible artifacts cause by the lossy compression steps.

\clearpage
